// https://leetcode.com/problems/house-robber/

Recursive Code : TLE
TC - O(n^2) due to recursive calls
SC - O(n) due to recursion
private int Robbery(int index, int[] nums){
        if(index == 0) return nums[0];
        if(index == 1) return Math.max(nums[0], nums[1]);
        
        return Math.max(nums[index] + Robbery(index-2, nums), Robbery(index-1, nums));
    }
    public int rob(int[] nums) {
        int n = nums.length;
        return Robbery(n-1, nums);
    }



Thought Process :
If there are no houses or only one house, return 0 or the value of that single house accordingly.
Initialize prevMax and currMax to the maximum money obtainable from the first house (nums[0]).
Apply dynamic programming by iterating from the second house to the last.
Update currMax to represent the maximum money with the current house by comparing the sum of prevMax and the current house's value with currMax.
Update prevMax with the previous value of currMax.
Return currMax as the final result.

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;

        if(n==0) return 0;
        if(n==1) return nums[0];
        

        int prevMax = 0;
        int currMax = nums[0];

        for(int i=1; i<n; i++){
            int temp = currMax;
            currMax = Math.max(prevMax + nums[i],currMax);
            prevMax = temp;
        }
        return currMax;
    }
}
